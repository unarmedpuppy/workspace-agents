#!/usr/bin/env node

/**
 * Reference Creator - Create new reference documentation
 *
 * Usage: npm run create
 *
 * Interactive prompts:
 * - Topic name (e.g., testing, database, api-design)
 * - Brief description
 * - Reference type (language, framework, workflow, general)
 * - Key sections to include
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

function ask(question) {
  return new Promise(resolve => rl.question(question, resolve));
}

const REFERENCE_TYPES = {
  language: {
    name: 'Language Reference',
    sections: [
      'Language Configuration',
      'Code Style',
      'Common Patterns',
      'Error Handling',
      'Testing Patterns',
      'Best Practices'
    ]
  },
  framework: {
    name: 'Framework Reference',
    sections: [
      'Setup and Configuration',
      'Core Concepts',
      'Common Patterns',
      'Testing',
      'Performance Tips'
    ]
  },
  workflow: {
    name: 'Workflow Reference',
    sections: [
      'Overview',
      'Step-by-Step Process',
      'Decision Points',
      'Common Issues',
      'Examples'
    ]
  },
  general: {
    name: 'General Reference',
    sections: [
      'Overview',
      'Guidelines',
      'Examples',
      'Best Practices'
    ]
  }
};

function toKebabCase(str) {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
}

function toTitleCase(str) {
  return str
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

function generateTemplate(topic, description, type, sections) {
  const title = toTitleCase(topic);
  const date = new Date().toISOString().split('T')[0];
  const typeInfo = REFERENCE_TYPES[type];

  let content = `# ${title}

${description}

## Overview

[Expand on the purpose and scope. What does this reference help with?]

`;

  for (const section of sections) {
    content += `## ${section}

[Add content for this section]

`;
  }

  content += `## Best Practices

- **Practice 1**: [Explanation]
- **Practice 2**: [Explanation]
- **Practice 3**: [Explanation]

## Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| [Issue 1] | [Why it happens] | [How to fix] |

## Related Resources

- [Related Skill](../skills/skill-name/) - [Relationship]
- [Related Persona](../personas/persona-name.md) - [Relationship]

---

*Generated by workspace-agents on ${date}*
`;

  return content;
}

async function main() {
  console.log('\nðŸ“š Reference Creator\n');
  console.log('Create focused reference documentation for agents/reference/\n');

  // Get topic name
  const topicRaw = await ask('Topic name (e.g., testing, database, api-design): ');
  const topic = toKebabCase(topicRaw.trim());

  if (!topic) {
    console.error('Error: Topic name is required');
    rl.close();
    process.exit(1);
  }

  // Get description
  const description = await ask('Brief description: ');

  if (!description.trim()) {
    console.error('Error: Description is required');
    rl.close();
    process.exit(1);
  }

  // Get reference type
  console.log('\nReference types:');
  console.log('  1. language  - Language patterns and standards');
  console.log('  2. framework - Framework-specific usage');
  console.log('  3. workflow  - Multi-step processes');
  console.log('  4. general   - Cross-cutting concerns');

  const typeChoice = await ask('\nReference type (1-4 or name): ');
  const typeMap = { '1': 'language', '2': 'framework', '3': 'workflow', '4': 'general' };
  const type = typeMap[typeChoice] || typeChoice.toLowerCase();

  if (!REFERENCE_TYPES[type]) {
    console.error(`Error: Invalid type "${type}". Use: language, framework, workflow, or general`);
    rl.close();
    process.exit(1);
  }

  // Confirm sections
  const typeInfo = REFERENCE_TYPES[type];
  console.log(`\nDefault sections for ${typeInfo.name}:`);
  typeInfo.sections.forEach((s, i) => console.log(`  ${i + 1}. ${s}`));

  const customSections = await ask('\nCustom sections (comma-separated, or Enter for defaults): ');
  const sections = customSections.trim()
    ? customSections.split(',').map(s => s.trim())
    : typeInfo.sections;

  // Generate and write file
  const content = generateTemplate(topic, description.trim(), type, sections);
  const outputDir = path.join(process.cwd(), '..', '..', '..', 'reference');
  const outputPath = path.join(outputDir, `${topic}.md`);

  // Ensure directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Check if file exists
  if (fs.existsSync(outputPath)) {
    const overwrite = await ask(`\nFile ${topic}.md already exists. Overwrite? (y/N): `);
    if (overwrite.toLowerCase() !== 'y') {
      console.log('Cancelled.');
      rl.close();
      process.exit(0);
    }
  }

  fs.writeFileSync(outputPath, content);
  console.log(`\nâœ“ Created: agents/reference/${topic}.md`);
  console.log('\nNext steps:');
  console.log('  1. Fill in the [placeholder] sections');
  console.log('  2. Add code examples with language specified');
  console.log('  3. Run: npm run validate to check completeness');

  rl.close();
}

main().catch(err => {
  console.error('Error:', err.message);
  rl.close();
  process.exit(1);
});
